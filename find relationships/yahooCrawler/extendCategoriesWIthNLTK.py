"""
Import the list of categories used by the Yelp's businesses.
Then for each category we try to find similar words that we will use later as keywords to be detected.
Similar words are:
- singular version of the word
- plural version of the word
- synonyms generated by Wordnet of the singular/category/plural name
- hyponyms generated by Wordnet of the singular/category/plural name
"""

import csv
from nltk.corpus import wordnet as wn
import re
from pattern.en import singularize, pluralize
import  time

maxDistanceParameter = 0.25

state = 'NV'

csvInputFileName = '../resultsFound/yahooCrawler/categories' + state + 'WithUrl.csv'
csvOutputFileName = '../resultsFound/yahooCrawler/categories' + state + 'ExtendedCategoriesWith025Improved2.csv'

dictOfCategories = {}

with open(csvInputFileName) as csvfile:
    reader = csv.DictReader(csvfile, quotechar="'", skipinitialspace=True)
    for row in reader:  # read a row as {column1: value1, column2: value2,...}
        # We replace every "\'" in the name of the category by the original "'"
        originalCategory = row["category"]
        category = originalCategory.replace("'","").replace("\\","'")
        dictOfCategories[category] = []

        if "&" in category or "/" or "," in category:
            """
            If we have Counseling & Mental Health
            we want:
            """

            # We split the category by "&" or "/" and "," and space
            categoriesSplitBySign = re.split("&|/|,| ", category)

            categoriesSplitBySign = filter(None, categoriesSplitBySign) # remove empty element (' ')

            extendedCategories = []

            categoriesSplitByAndSignAndSpaces = []  # Will represent every word of this list without & or space
            for categorySplitByAnd in categoriesSplitBySign:
                categoriesSplitByAndSignAndSpaces.extend(categorySplitByAnd.split(" "))

            # We add all the combinaisons possible
            for row1 in categoriesSplitByAndSignAndSpaces:
                for row2 in categoriesSplitByAndSignAndSpaces:
                    if row1 != row2:
                        newCategory = row1 + " " + row2
                        extendedCategories.append(newCategory.strip())

            #For the categories that we can split by comma and and sign, we add them indivudally
            # e.g.: 'Beer, Wine & Spirits' => ['Beer', 'Wine', 'Spirits'] that we will add one by one.
            categoriesSplitBySign = re.split("&|,|/", category)
            categoriesSplitBySign = [x.strip() for x in categoriesSplitBySign]
            categoriesSplitBySign = filter(None, categoriesSplitBySign) # remove empty element (' ')
            extendedCategories.extend(categoriesSplitBySign)

            dictOfCategories[category].extend(extendedCategories)


lengthOfDict = len(dictOfCategories)
i = 0
for category in dictOfCategories:
    t0 = time.time()
    i += 1
    print str(i) + "/" + str(lengthOfDict)
    listOfCategoriesSingularAndPlural = []
    for subCategory in dictOfCategories[category]:
        listOfCategoriesSingularAndPlural.append(singularize(subCategory))
        listOfCategoriesSingularAndPlural.append(pluralize(subCategory))

    dictOfCategories[category].extend(listOfCategoriesSingularAndPlural)

    synsetCategories = wn.synsets(category)
    if synsetCategories:
        for synsetCategory in synsetCategories:
            lemmaNames = synsetCategory.lemma_names()
            hyponyms = synsetCategory.hyponyms()
            if hyponyms:
                hyponymsLemmaNames = []
                for row in hyponyms:
                    hyponymsLemmaNames.extend(row.lemma_names())
            else:
                hyponymsLemmaNames = ''
            dictOfCategories[category].extend(lemmaNames)
            dictOfCategories[category].extend(hyponymsLemmaNames)

    listOfSingularAndPluralCategoriesSynsets = []
    for categorySingularAndPlural in listOfCategoriesSingularAndPlural:
        synsetCategories = wn.synsets(categorySingularAndPlural)
        listOfSingularAndPluralCategoriesSynsets.extend(synsetCategories)
        if synsetCategories:
            for synsetCategory in synsetCategories:
                lemmaNames = synsetCategory.lemma_names()
                hyponyms = synsetCategory.hyponyms()
                if hyponyms:
                    hyponymsLemmaNames = []
                    for row in hyponyms:
                        hyponymsLemmaNames.extend(row.lemma_names())
                else:
                    hyponymsLemmaNames = ''
                dictOfCategories[category].extend(lemmaNames)
                dictOfCategories[category].extend(hyponymsLemmaNames)

    dictOfCategories[category] = filter(None, dictOfCategories[category]) # remove empty element

    if category in dictOfCategories[category]:
        dictOfCategories[category].remove(category) #no duplicate between category name and content of the list

    #Now we clean our list of categories
    listOfNewKeywords = []
    for potentialNewKeyword in dictOfCategories[category]:
        synsetsOfPotentialNewKeyword = wn.synsets(potentialNewKeyword)
        synsetsOfOriginalCategory = wn.synsets(category)
        synsetsOfOriginalCategory.extend(listOfSingularAndPluralCategoriesSynsets)
        maxDistance = 0
        for synsetOfPotentialNewKeyword in synsetsOfPotentialNewKeyword:
            for synsetOfOriginalCategory in synsetsOfOriginalCategory:
                distance = synsetOfPotentialNewKeyword.path_similarity(synsetOfOriginalCategory)
                if distance > maxDistance:
                    maxDistance = distance

        if maxDistance > maxDistanceParameter:
            listOfNewKeywords.append(potentialNewKeyword)

    dictOfCategories[category] = listOfNewKeywords

    dictOfCategories[category].extend(listOfCategoriesSingularAndPlural)
    dictOfCategories[category] = [x.encode('UTF8').replace("_", " ").replace("'", r"\'").strip().lower() for x in dictOfCategories[category]] #Remove space at the beginning/end of strings and escape the quotes
    dictOfCategories[category] = list(set(dictOfCategories[category])) #Remove duplicates
    if category.lower() in dictOfCategories[category]:
        dictOfCategories[category].remove(category.lower())

    t1 = time.time()
    print t1 - t0

f = open(csvOutputFileName, 'w')
for category in dictOfCategories:
    data = "'" + category.replace("'", r"\'") + "'"
    for row in dictOfCategories[category]:
        data += "," + "'" + row + "'"

    f.write(data + "\n")
